#!/usr/bin/octave -q

pkg load signal;

function write_array(file_id, name, array_data)
    len_name = sprintf('%s_LEN', toupper(name));
    data_name = sprintf('%s_DATA', toupper(name));

    fprintf(file_id, '#define %s %d\n', len_name, length(array_data));
    fprintf(file_id, '#define %s \\\n', data_name);
    fprintf(file_id, '{ \\\n');
    for i = 1 : length(array_data)
        if(mod(i-1, 8) == 0)
            fprintf(file_id, '    ');
        end
        if(i == length(array_data))
            fprintf(file_id, '%13e ', array_data(i));
        else
            fprintf(file_id, '%13e, ', array_data(i));
        end
        if(mod(i, 8) == 0)
            fprintf(file_id, '\\\n');
        end
    end
    fprintf(file_id, '}\n');
    fprintf(file_id, 'static TEST_CONST_SECTION const float %s[%s] = %s;\n\n', name, len_name, data_name);
end

% Filter lengths
fir_len = [ 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 ];

% Generate random input
randn('seed', 0);
input_signal = single([randn(max(fir_len), 1); zeros(max(fir_len), 1)]);

% Write header file
fh = fopen( 'src/test_vectors.h', 'w' );
fprintf(fh, '// Autogenerated file, do not edit.\n\n');
fprintf(fh, '// clang-format off\n\n');
fprintf(fh, 'int get_num_fir(void);\n');
fprintf(fh, 'int get_fir_length(int fir_index);\n');
fprintf(fh, 'const float *get_fir_coeffs(int fir_index);\n');
fprintf(fh, 'int get_input_length(void);\n');
fprintf(fh, 'const float *get_input(void);\n');
fprintf(fh, 'int get_output_length(int fir_index);\n');
fprintf(fh, 'const float *get_output(int fir_index);\n');
fclose(fh);

% Write C file
fir_name = {};
fir_coeffs = {};

fc = fopen( 'src/test_vectors.c', 'w' );
fprintf(fc, '// Autogenerated file, do not edit.\n\n');
fprintf(fh, '// clang-format off\n\n');
fprintf(fh, '#include "macro.h"\n\n');
for filter_idx = 1 : length(fir_len)
    fir_name{filter_idx} = sprintf('fir_%d', fir_len(filter_idx));

    % This will generate an asymmetric coefficient array so we can catch
    % problems related to coeff reversal used in some impementations
    padding_size = 2;
    b = fir1(fir_len(filter_idx) - padding_size - 1, [0.1, 0.4], "pass");
    b = [zeros(1,padding_size) b];
    fir_coeffs{filter_idx} = single(b);
    write_array(fc, fir_name{filter_idx}, fir_coeffs{filter_idx});
end

write_array(fc, 'input_vector', input_signal);
for filter_idx = 1 : length(fir_len)
    output_name = sprintf('output_vector_%s', fir_name{filter_idx});
    y = single(filter(fir_coeffs{filter_idx}, 1, input_signal));
    write_array(fc, output_name, y);
end

fprintf(fc, 'static const struct\n');
fprintf(fc, '{\n');
fprintf(fc, '    int fir_length;\n');
fprintf(fc, '    const float *fir_coeffs;\n');
fprintf(fc, '    int output_length;\n');
fprintf(fc, '    const float *output_samples;\n');
fprintf(fc, '} filter_data[%d] =\n', length(fir_len));
fprintf(fc, '{\n');
for filter_idx = 1 : length(fir_len)
    fprintf(fc, '    { %s, %s, %s, %s }',
            sprintf('FIR_%d_LEN', fir_len(filter_idx)),
            sprintf('fir_%d', fir_len(filter_idx)),
            sprintf('OUTPUT_VECTOR_FIR_%d_LEN', fir_len(filter_idx)),
            sprintf('output_vector_fir_%d', fir_len(filter_idx)));
    if (filter_idx < length(fir_len))
        fprintf(fc, ',');
    end
    fprintf(fc, '\n');
end

fprintf(fc, '};\n\n');
fprintf(fc, 'int get_num_fir(void)\n');
fprintf(fc, '{\n');
fprintf(fc, '    return %d;\n', length(fir_len));
fprintf(fc, '}\n\n');
fprintf(fc, 'int get_fir_length(int fir_index)\n');
fprintf(fc, '{\n');
fprintf(fc, '    return filter_data[fir_index].fir_length;\n');
fprintf(fc, '}\n\n');
fprintf(fc, 'const float *get_fir_coeffs(int fir_index)\n');
fprintf(fc, '{\n');
fprintf(fc, '    return filter_data[fir_index].fir_coeffs;\n');
fprintf(fc, '}\n\n');
fprintf(fc, 'int get_input_length(void)\n');
fprintf(fc, '{\n');
fprintf(fc, '    return INPUT_VECTOR_LEN;\n');
fprintf(fc, '}\n\n');
fprintf(fc, 'const float *get_input(void)\n');
fprintf(fc, '{\n');
fprintf(fc, '    return input_vector;\n');
fprintf(fc, '}\n\n');
fprintf(fc, 'int get_output_length(int fir_index)\n');
fprintf(fc, '{\n');
fprintf(fc, '    return filter_data[fir_index].output_length;\n');
fprintf(fc, '}\n\n');
fprintf(fc, 'const float *get_output(int fir_index)\n');
fprintf(fc, '{\n');
fprintf(fc, '    return filter_data[fir_index].output_samples;\n');
fprintf(fc, '}\n');
fclose(fc);
